러스트의 메모리 관리는 이상적인 형태로 구현돼 있음
이런 이상을 위해 어느 정도 제한도 존재함
가변 전역 변수, 메모리 변조 위험성이 있는 포인터 역참조, 다른 언어로 구현된 라이브러리 등 러스트의 안전성을 해칠 가능성이 있는 것은 컴파일러가 에러를 발생 시키니다. 즉 러스트 컴파일러는 위험성이 있는 행위나 기능은 금지함
하지만 추천하지 않는 행위에 대해 안전하지 않다는 것을 명시하면 이를 이용할 수 있다. 이것이 바로 unsafe임
## 의사 난수 생성
가변 전역 변수를 이용해 의사 난수를 만들며 unsafe를 사용해보기
2장에서는 rand 크레이트를 이용해 난수를 생성하는 프로그램을 만들었으나 여기서는 외부 공개 크레이트 없이 의사 난수를 만드는 방법을 소개함

## 난수 발생기 준비
rand 크레이트로 난수를 만들 때 난수 발생기를 먼저 선언한 뒤 해당 난수 생성기를 이용해 난수를 만들었음
그리고 난수 생성기를 변수에 대입하기 위해 변수에 &mut를 지정해 가변 변수로 선언해야 한다.
```rust
// 난수 생성기 준비
let mut rng = rand::thread_rng()

// 1~6 사이의 난수를 생성
let dice = rng.gen_range(1..=6);
```

## '좋은 난수 생성' 구조
대부분의 프로그래밍 언어에는 난수를 생성하는 라이브러리가 준비돼 있지만 구현 방법은 프로그램마다 다름
난수는 컴퓨터가 가진 기능을 이용해 생성하는 것이 아니라 프로그램이 특정한 계산을 통해 의사 난수를 만드는 것임

### 파이썬으로 의사 난수 생성
Xorshift라는 알고리즘을 이용해 의사 난수를 생성함
간단하지만 꽤 좋은 난수를 생성할 수 있음
```python
import time

# 난수 생성을 위한 Seed를 전역 변수로 선언
SEED = 0

# start부터 end 사이의 난수를 생성
def rand(start, end):
	global SEED
	# 난수 초기화
	if SEED == 0:
		# 현재 시각으로 Seed를 초기화
		SEED = int(time.time() * 1000)
	# 난수 생성
	SEED ^= (SEED << 13) & 0xFFFFFFFF
	SEED ^= (SEED >> 17) & 0xFFFFFFFF
	SEED ^= (SEED << 5) & 0xFFFFFFFF
	return SEED % (end - start + 1) + start

# 난수 100개를 생성
for _ in  range(100):
	print(rand(1, 6))
```

## 러스트에서 전역 변수 이용하기
러스트에서 의사 난수 생성을 하기 전에 먼저 알아야 할 것이 있음
바로 '전역변수' 파이썬에서 전역 변수 SEED를 이용해 난수의 초깃값을 만든 후 난수를 생성했음

### 가변 전역 변수 사용하기
```rust
// 전역 가변 변수 선언
static mut TAX: f32 = 0.1;

fn main() {
	// 안전하지 않다는 것을 명시
	unsafe {
		// 가변 전역 변수 사용
		println!("Price: {}", TAX * 300.0);
		// 가변 전역 변수의 값 변경
		TAX = 0.08;
		println!("Price: {}", TAX * 300.0)
	}
}
```
이 코드는 이용할 가변 전역 변수를 선언 했다. 가변 전역 변수를 정의할 때는 unsafe를 명시하지 않아도 괜찮음
하지만 실제로 이 변수를 이용하는 부분은 unsafe 블록을 이용해 감싸야함
전역 변수의 값을 바꾸는게 문제가 아니라 가변 전역 변수를 사용한다는 것 자체가 문제가 된다는 것을 의미함
unsafe로 감싸지 않으면 에러가 표시된다.

### 전역 변수를 이용해 난수 생성
가변 전역 변수를 이용해 파이썬에서 만들었던 것과 동일한 난수 생성 프로그램 만들어보기
```rust
use std::time::{SystemTime, UNIX_EPOCH};

// 전역 변수로 이용할 난수 Seed 지정
static mut SEED: u32 = 0;

// start부터 end 사이의 난수를 생성하는 unsafe 함수
unsafe fn rand_global(start: u32, end: u32) -> u32 {
	// 필요하다면 Seed값 초기화
	if SEED == 0 {
		// 현재 시각을 이용해 난수 초기화
		let epoc = SystemTime::now()
			.duration_since(UNIX_EPOCH).unwrap();
		SEED = epoc.as_millis() as u32;
	} 
	// Seed를 이용해 난수 생성
	SEED ^= SEED << 13;
	SEED ^= SEED >> 17;
	SEED ^= SEED << 5;
	return SEED % (end - start + 1) + start;
}

fn main() {
	for _ in 0..100 {
		// 안전하지 않다는 것을 명시
		unsafe {
			// 난수를 생성해 출력
			let v = rand_global(1, 6);
			println!("{}", v);
		}
	}
}
```
난수의 시작 값이 될 변수 SEED를 가변 전역 변수로 선언하고 이 변수에 접근하는 것은 안전하지 않으므로 unsafe로 감싸야함 SEED에 접근하기 위해 함수 자체를 unsafe로 지정한다. unsafe fn 함수 이름과 같이 지정하면 가변 전역 변수에 접근할 수 있다. SEED를 초기화해야하는 경우가 발생하면 현재 시각을 이용해 초기화한다. 초깃값을 이용해 난수를 생성한다. 이 난수의 생성 처리는 파이썬과 거의 같음

unfafe 블록을 지정해 unsafe블록 안에서 안전하지 않은 함수 rand_global을 호출할 수 있게 한다.
이처럼 unsafe 함수를 호출할 때도 반드시 unsafe를 명시해야한다.

### 유닉스(에프크) 시간을 얻는 방법
유닉스 시간은 시각을 나타내는 방식이다. POSIX 시간이나 에포크 시간이라고 부르기도 함
세계시 UTC부터의 경과 시간을 초로 환산하여 정수로 나타낸 것
러스트에서는 다음과 가은 절차로 유닉스 시간을 취득이 가능하다.
- now 메서드로 현재 시간을 나타내는 객체 취득
- duration_since 메서드를 이용해 유닉스 시간 취득 시도
- as_millis 메서드를 이용해 실젯값 취득

duartion_since 메서드는 값을 제대로 취득했는지 확인할 수 있도록 Result타입 (Result<Duration, SystemTimeError>)을 반환한다. 여기서는 match로 에러 처리를 하지 않고 unwarp 메서드로단순히 값만 가져오도록 했으므로 값을 가져오는데 실패하면 패닉 에러가 발생해 시스템이 강제 종료된다.

### unsafe 이용을 최소화 할 것
러스트에서도 전역 변수 자체는 이용할 수 있지만 unsafe(안전하지 않은) 취급을 한다. 일부러 unsafe를 지정해야 한다는 것을 생각하면 이용하지 않는 것이 좋다는 것을 알 수 있다. 결론적으로 unsafe 이용은 최소한으로 하는 것이 좋다.

## unsafe를 이용하지 않고 의사 난수 만들기
앞의 예제에서는 가변 전역 변수를 이용해 난수를 만들었음
unsafe를 명시해야하는 추천하지 않는 방법을 이용했다.
그런 의미에서 rand 크레이트는 러스트의 구현의 모범적인 모습이라 할 수 있음
다음 예시는 rand 크레이트도, 가변 전역 변수도 이용하지 않고 난수를 생성한다.
```rust
use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
	// 난수 초기화
	let mut seed = rand_init();
	// 100개의 난수를 만들기 위한 반복문
	for _ in 0..100 {
		// 난수 생성
		let v = rand(&mut seed, 1, 6);
		println!("{}", v);
	}
}

// 난수 초깃값을 만드는 함수
fn rand_init() -> u32 {
	// 현제 시각을 이용해 난수 초깃값을 만든다.
	SystemTime::now()
		.duration_since(UNIX_EPOCH).unwrap()
		.as_millis() as u32
}

// start부터 end 사이의 난수를 생성하는 함수
fn rand(seed: &mut u32, start: u32, end: u32) -> u32 {
	*seed ^= *seed << 13;
	*seed ^= *seed >> 17;
	*seed ^= *seed << 5;
	return *seed % (end - start + 1) + start;
}
```

난수 초깃값을 만드는 함수
현재 시각을 유닉스 시간으로 변환해 난수의 초깃값을 만듦
만든 초기 값을 이용해 난수를 생성하는 함수임
첫 번째 인수로 받은 난수의 초깃값을 이용해 의사 난수를 생성한다.
\*seed 부분
seed는 가변 참조자 타입으로 \*을 붙여 실제값을 가져올 수 있다.
인수로 받은 seed의 값에 직접 xorshift 연산을 한다.
따라서 한번 rand 함수가 호출되면 seed값이 바뀐다. 따라서 난수를 생성할 때마다 다른 초기값을 이용한다.

난수 생성에서 중요한 점은 초기값을 만드는 것임
여기서는 유닉스 시간을 이용해 초기화한 뒤 rand 함수를 호출할 때마다 초기값을 바꾸므로 안정적으로 난수를 생성할 수 있음

> Xorshift
> Xorshift는 XOR 연산과 비트 시프트 연산을 하는 알고리즘이다.
> 비트 시프트 연산은 2진수의 비트를 옮기는 것을 말함
> \>> 비트값을 주어진 숫자만큼 오른쪽으로 이동
> \<< 비트값을 주어진 숫자만큼 왼쪽으로 이동
> 왼쪽으로 이동시키는 경우 2배수의 곱이 되며, 오른쪽으로 이동하는 경우 2배수의 나눗셈이 된다.
> 왼쪽으로 1비트를 움직인 경우 00010100 은 10인데 00101000은 20이 된다. 두배가 되는 것임
> 반대로 오른쪽으로 1비트 움직인 경우는 절반이 된다.

예제 소스 코드와 같이 비트 시프트 (>>, <<)를 한 뒤 XOR 연산(^=)을 하는 것이 Xorshift임
[연산자에 대한 자세한 내용](https://rinthel.github.io/rust-lang-book-ko/appendix-02-operators.html)
Xorshift는 간편하고 빠르게 난수를 생성할 수 있지만 몇 난수 품질 테스트를 통과하지 못하는 경우도 있어 이를 보강한 다양한 변종이 나와 있다.

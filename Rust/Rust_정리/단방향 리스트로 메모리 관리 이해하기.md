프로그램을 만들다 보면 특정 데이터 타입을 만들어야 하는 경우가 발생한다.
이 섹션에서는 사용자 데이터 타입을 정의하는데 빼놓을 수 없는 메모리 관리와 힙 영역 메모리를 확보하는 Box\<T>에 대해 알아본다.

## 단방향 연결 리스트 구현
지금까지 러스트이 기본 데이터 타입을 이용해 프로그램을 구현했다.
러스트의 메모리 관리를 제대로 이해해기 위해서는 보다 저수준의 처리를 다뤄야한다.

이 섹션에서는 단방향 리스트 알고리즘을 구현하며 러스트의 메모리 관리를 알아본다.
이 섹션에서는 힙 메모리를 확보하는 Box\<T>도 간단하게 다뤄본다.
Box\<T>는 이 장의 후반 프로그램에서 활용한다.

### 단방향 연결 리스트란
단방향 연결 리스트는 신축성 있는 데이터 타입으로 데이터의 추가/삭제가 쉽다는 특징이 있다. 복수의 노드로 구성되며 각 노드에는 데이터와 다음 노드를 가리키는 링크(포이터)를 가지고 있다.
단방향 연결 리스트를 그림으로 표현하면

| 데이터      |     | 데이터      |     | 데이터      |     |          |
| -------- | --- | -------- | --- | -------- | --- | -------- |
| 다음 노드 링크 | ->  | 다음 노드 링크 | ->  | 다음 노드 링크 | ->  | 없음(None) |
물론 러슽의 Vec\<T> 타입을 이용하는 것이 가장 편리하지만 여기서는 메모리 관리를 이해하기 위해 직접 단방향 연결 리스트를 구현한다.

### 기본 개념만을 이용한 구현
앞의 그림과 같이 데이터와 다음 노드 링크가 만들어지게끔 구성해보자.
노드를 구조체로 만들고, 한 노드에서 다음 노드를 지정하기 위해서는 구조체를 재귀 형태로 만들면 된다.
```rust
pub struct Node {
	data: i64,
	link: Option<Node>
}
fn main() {
	let mut c = Node{data: 30, link: None};
	println!("{}", c.data);
}
```

이 소스코드에는 문제가 있다. Node 구조체는 재귀 호출을 하게끔 구성돼 있는데 위 소스 코드에서는 재귀호출이 얼마나 발생할지 알 수 없기 때문에 메모리를 할당할 수 없기 때문이다.
실제로 컴파일을 하면 재귀 타입 Node의 크기가 무한대가 된다는 에러 메시지가 표시된다.

러스트는 컴파일할 때 프로그램의 메모리 할당에 문제가 없어야 한다. 하지만 자기 자신을 요소로 가지는 구조체, 즉 재귀 타입 구조체는 실제로 어느 정도 메모리를 할당해야 하는지 알 수 없기 때문에 메모리 할당에 문제가 생긴다.

### Box\<T>를 이용한 구현
앞의 예제에서 발생한 에러르 ㄹ잘 살펴보면 Box\<Node> 형태로 데이터 타입을 넣어보라는 조언을 볼 수 있다. 이 Box\<T>는 T 타입 데이터를 힙 영역에 저장할 것을 요구하는 데이터 타입이다. 제네릭 \<T> 부분에는 임의의 데이터 타입을 지정할 수 있으므로 Node 역시 지정 가능하다.
3 장에서 소유권 시스템을 설명할 때 언급한 것처럼 메모리는 힙 메모리와 스택 메모리가 있다. 그리고 스택 메모리는 순차적 접근만을 허용하고 힙 메모리는 임의의 장소에 있는 값에 접근할 수 있다.

예를 들어 Box\<i64> 로 객체를 생성한다면 힙 영역에 i64 데이터가 확보되고 스택 영역에는 힙 영역을 가리키는 고정 크기 포인터만 확보된다.
즉 앞의 단방향 연결 리스트에서 다음 노드의 링크 부분을 Box\<Node> 형태로 지정하면 재귀 호출로 인한 에러가 발생하지 않는다.

```rust
// 단방향 연결 리스트 - 1
pub struct Node {
	data: i64,
	link: Option<Box<Node>>
}

// 단방향 연결 리스트를 생성하는 함수 - 2
fn node(v: i64, link: Option<Box<Node>>) -> Option<Box<Node>> {
	Some(Box::new(Node{data:v, link:link}))
}

fn main() {
	// 단방향 연결 리스트 생성 - 3
	let c = ndoe(10, node(20, node(30, None))).unwrap();
	
	// 가장 앞에서부터 각 요소를 따라가며 값을 표시 - 4 
	let mut p = &c;
	loop {
		println!("{}", p.data);
		// p가 다음 요소를 가리키도록 변경 - 5
		match p.link {
			None => break,
			Some(ref link) => p = &link,
		}
	}
}
```
1의 Node 구조체에는 에러 메시지의 조언과 같이 Box\<Node>를 지정해 컴파일을 할 때 구조체의 크기를 결정할 수 있게 해 메모리 문제를 해결했다.
2는 노드를 간편하게 만드는 함수 node의 정의다. 다음과 같이 Box::new(값) 형태로 힙 영역에 값이 저장될 메모리를 확보하고 값을 저장한다.

> \[서식] Box\<T>를 이용한 힙 메모리 확보 및 저장
> let p = Box::new(값);

3에서는 함수 node를 이용해 3개의 노드를 생성한다.

4에서는 첫 번째 요소인 c의 참조를 가변 변수 p로 받는다. 그리고 리스트의 마지막 요소, 즉 다음링크가 None이 될 때까지 loop를 이용해 반복한다.
5 부분에서는 변수 p를 다음 요소, 즉 link의 노드를 변경한다. 여기서 link는 Option 타입이므로 match를 이용해 다음 요소가 잇는지를 판단해 다음 요소가 없다면(None이면) loop를 빠져나온다. 만약 다음 요소가 있다면 p값을 다음 요소로 바꾼다.

### Box\<T>를 이용했을 때의 메모리 형태
Box\<T>를 이용하는 경우 어떻게 메모리가 확보되는지 확인해보자. 위의 프로그램에서 3개의 노드가 만들어졌을 때의 메모리는 스택 영역 -> 힙영역
Box::new 함수를 사용해 메모리를 확보하면 힙 영역에 Node 객체의 본체가 저장된다.
이 구조라면 힙 영역에 Node 객체가 몇 개가 만들어지더라도 스택 영역의 포인터 크기는 변하지 않는다. 따라서 컴파일을 할 때 스택에 확보할 메모리 크기도 결정할 수 있기 때문에 컴파일 에러가 발생하지 않는다. 재귀적인 구조체를 만들거나 특수한 알고리즘을 이용해야 하는 경우라면 이처럼 Box\<T>를 이용해 메모리 문제를 해결할 수 있다.

### Null을 어떻게 표현하는가
러스트는 값이 없다는 것을 나타내기 위한 Null이 존재하지 않는다.
위와 같이 재귀적으로 자신을 포함하는 Node 객체를 만들었을 때 link가 다른 Node 객체를 가리키는가 아니면 비어 있는가를 판단하는 방법을 준비해야 한다.

앞의 예제에서는 Option 타입을 이용한다. Option 타입은 None 혹은 Some(T)를 반환하므로 가리킬 Node 객체가 없다면, None, 값이 있다면 Some(Box\<Node>)를 반환한다.

### 열거형 enum으로 구현
열거형 enum을 이용해서 단방향 연결 리스트를 구현할 수도 있다.
열거형은 자신이 비어 있을 때 Empty를 반환하고 값이 있다면 자신과 자신을 가리키는 포인터를 반환하도록 구조체를 정의한다. 앞에서 만든 단방향 연결 리스트를 열거형 리스트로 만들어 보기
```rust
// 열거형으로 Node를 정의 - 1
enum Node {
	Empty,
	Cons(i64, Box<Node>),
}

// 열거형을 더 쉽게 사용할 수 있게 해주는 선언 및 함수 - 2
ues Node::{Empty, Cons};
fn node(v: i64, link: Box<Node>) -> Box<Node> {
	Box::neew(Cons(v, link))
}
fn main() {
	// 단방향 연결 리스트 생성 - 3
	let c = ndoe(10, node(20, node(30, Box::new(Empty))));
	
	// 가장 앞에서부터 각 요소를 따라가며 값을 표시 - 4
	let mut ptr: &Node = &**ptr;
	loop {
		// &Box<Node>에서 Node를 꺼내와 출력 - 5
		match cur_node {
			Empty => break,
			Cons(v, link) => {
				println!("{}", v);
				ptr = &link;
			}
		}
	}
	
}
```
1에서 열거형 Node를 정의했고
Node는 Empty와 Cons 중 하나가 된다.
Cons는 2개의 요소 (i64 타입과 Box\<Node>)를 갖는 튜플이다.

2에서는  열거형을 다루기 쉽도록 use를 이용해 선언한다. 이것으로 Node::Empty 대신 Empty를 Node::Cons 대신 Cons를 사용할 수 있다.
Node 열거형을 이용해 연결 리스트를 생성할 함수 node를 정의한다.
3은 앞의 예제와 마찬가지로 node를 생성하는 부분이다.
4 부분도 알고리즘 자체는 구조체를 사용했을 때와 동일하다
5에서는 Node의 값을 꺼내와 값이 비었는지를 확인해 비어 있다면 반복문을 종료하고, 그렇지 않ㅎ다면 다음 노드를 가리키는 값으로 변경한다. Box\<T>에서 값 T를 가져오는 방법과 역참조를 하는 방법은 뒤에 설명한다.

### Box\<T> 에서 값 T를 가져오는 방법
Box\<T>에서 값 T를 가져오려면 역참조를 이용한다.

```rust
fn main() {
	// 힙 메모리에 100을 저장하고 포인터를 반환
	let x_box = Box::new(100);
	// 역참조를 해서 원래의 값을 가져온다
	let x_val = *x_box;
	println!("{}", x_val);
}
```
코드 설명
Box::new(100)을 이용해 값 100을 힙 영역에 저장하고, 저장한 메모리 주소를 가리키는 포인터(Box 객체. Box\<i32>)를 변수 x_box에 대입 한다. 즉 x_box는 참조자가 된다.
그리고 x_box의 역참조(\*x_box)를 이용하면 참조하는 곳의 실젯값을 가져올 수 있다.

### '역참조'와 '참조' 찾기
list_enum.rs의 4 이후 부분을 보면 Box\<Node>의 참조자를 변수 ptr에 대입하고 있다. 그리고 loop문으로 Node 요소를 순서대로 출력한다. 값을 꺼낼 때의 구문을 보면 다음과 같다.
```
let cur_node: &Node = &**ptr;
```
러스트에서는 참조자를 얻기 위해서는 '&'을 붙이고, 
역참조를 위해서는 '\*'를 사용한다.
그렇다면 '\&\*\*ptr'은 무엇을 가리키는지 생각해보자.
여기서 하는 작업이 &Box\<Node> 타입 변수 ptr에서 힙에 있는 Node 참조자(&Node 타입)를 꺼내는 것이다.

| 조작  | 표현       | 의미                                  |
| --- | -------- | ----------------------------------- |
| 0   | ptr      | (전제) 변수 ptr은 &Box\<Node> 타입         |
| 1   | \*ptr    | 역참조를 수행하므로 Box\<Node> 타입을 얻는다.      |
| 2   | \*\*ptr  | Box\<T>에서 값 T를 역참조하므로 Node 타입을 얻는다. |
| 3   | &\*\*ptr | Node에 대한 참조자를 얻으므로 &Node 타입을 얻는다.   |

참조와 역참조의 동작을 잘 이해해야 한다.
러스트에서는 타입 추론 기능이 있어 변수에 타입을 지정하지 않는 경우가 많은데 이 예제 코드와 같이 참조와 역참조를 많이 사용하는 경우 원래의 타입을 모르면 역참조를 어떻게 해야할지, 참조를 어떻게 해야할지 알기 힘들 수 있으믈 데이터 타입이 복잡해질때는 변수의 타입을 명시해주는 것이 좋다.

## 단방향 연결 리스트에 메서드 구현
이번에는 단방향 연결 리스트를 라이브러리로 생성해본다.
단방향 연결 리스트에 값을 추가하는 메서드와 특정 인덱스 값을 가져오는 메서드를 생성하고 이 메서드를 이용하는 메인 함수를 구현한다.

slist라는 프로젝트 생성
외부 크레이트를 이용하지 않으므로 Cargo.toml파일은 수정하지 않음
2개의 파일로 나눠 프로그램을 구현하므로 src 디렉터리에 main.rs파일외에 slist.rs 라는 추가파일을 생성

메인함수 구현
```rust
mod slist;
fn main() {
	// 리스트 객체 생성
	let mut list = slist::List::new();
	// 리스트의 끝에 값을 추가
	list.push(100);
	list.push(200);
	// 리스트의 앞에 값을 추가
	list.unshift(10);
	list.unshift(20);
	// 지정한 인덱스에서 값 가져오기
	println!("{}", list.get(0).unwrap());
	println!("{}", list.get(1).unwrap());
	println!("{}", list.get(2).unwrap());
	println!("{}", list.get(3).unwrap());
}
```

메인 함수에서 사용할 수 있는 slist 모듈을 구현한다. 모듈을 초기화하는 new, 리스트에 값을 추가하는 push와 unshift, 지정한 인덱스에서 값을 가져오는 get 메서드를 구현해야한다.

```rust
// 단방향 연결 리스트에서 사용할 한 요소의 구조체 -1
pub struct Node {
	data: isize,
	link: Option<Box<Node>>,
}
// 단방향 연결 리스트 자체의 구조체 -2
pub struct List {
	head: Option<Box<Node>>,
}
// List 구조체의 메서드 구현 -3
impl List {
	pub fn new() -> Self { // 생성자
		Self{head: None}
	}
	// 리스트의 제일 앞에 값을 추가 -4
	pub fn unshift(&mut self, v:isize) {
		let new_node = Node{data: v, link: self.head.take()};
		self.head = Some(Box::new(new_node));	
	}
	// 리스트의 제일 끝에 값을 추가 -5
	pub fn push(&mut self, v:isize) {
		// 새로운 값
		let new_node = Node{data: v, link: None};
		match self.head {
			None => self.head = Some(Box::new(new_node)),
			Some(ref mut head) => {
				// 현재의 가장 끝 노드를 찾아 새로운 노드에 연결
				let mut p = head;
				loop {
					match p.link {
						None => { // 가장 끝 노드
							p.link = Some(Box::new(new_node));
							break;
						},
						Some(ref mut next) => p = next,
					}
				}
			}
		}
	}
	// 지정한 인덱스의 값을 가져오기 -6
	pub fn get(&self, index: isize) -> Option<isize> {
		match self.head {
			None => return None, // 리스트가 비었을 때
			Some(ref top) => {
				// 지정한 인덱스 값 찾기
				let mut p = top;
				let mut i = 0;
				loop {
					if i == index { // 찾았을 때
						return Some(p.data);
					}
					match p.link { // 다음 요소 찾기
						None => return None,
						Some(ref link) => p = link,
					}
					i += 1;
				}
			}
		}
	}
}
```

Node 구조체 정의고 2는 구조체로 이루어진 리스트에 대한 구조체를 정의한 것이다.
List 구조체에 대한 메서드를 구현한다. 메인 함수에서 이용할 unshift, push, get을 정의하고 있다.

리스트의 제일 앞에 값을 추가하는 4 unshift 메서드의 구현은 간단하다. 가장 앞에 값을 추가하므로 현재 목록의 가장 처음(head)에 있는 Node의 link를 가져와 새로운 Node에 값을 추가한다. 그리고 현재 List 값을 새로운 값으로 갱신한다.

여기서 self.head에 take 메서드를 이용해 데이터를 꺼내 소유권을 이동한다. self.head 자체의 소유권을 새로운 Node의 link로 옮기고 싶어도 self를 &mut self로 지정해 소유권이 이동하지 않기 때문에 Option::take 메서드를 이용하는 것이다.

5 리스트의 제일 끝에 값을 추가하는 메서드다. 이 메서드는 조금 복잡하다. 우선 새로운 Node를 만든 뒤 head 값을 이용해 현재 리스트의 가장 끝 Node가 아니므로 다음 Node를 찾는다. 이렇게 해서 link 값이 없는 Node를 찾아 해당 link의 값을 새로 생성한 Node로 변경하고 반복문을 종료한다.

6 지정한 인덱스의 값을 가져오는 메서드다. 이 메서드에서도 지정한 인덱스 값을 찾기 위해 첫 번째 Node부터 순서대로 link를 탐색한다. 몇 번째 Node인지 세기 위한 변수 i를 준비해 하나씩 증가시켜가며 Node를 찾아간다.

이 단방향 연결 리스트 구조는 매우 효율이 나쁘다. 다음 섹션에서는 이 알고리즘을 개선해본다.


러스트의 모듈은 트리 구조로 표현된다. 이런 모듈의 모음을 크레이트 라고 한다.
크레이트를 관리하는 것이 패키지다.
이 섹션에서는 러스트의 패키지, 크레이트, 모듈의 동작에 대해 알아본다.

## 왜 기능별로 분리해야 하는가?
먼저 모듈과 크레이트가 필요한 이유를 생각해보자
기본적으로 모듈이나 크레이트라는 것은 프로그램을 나누는 단위다.

프로그램을 나누는 이유는 무엇일까?
대규모 시스템을 구축한다면 프로그램을 기능별로 분리하는 것이 유리하다.
프로그램을 기능별로 나누면 프로그램의 구조를 알기 쉽게 되며 해당 기능 개발에 집중하기 쉬워진다.
그리고 업무 분담도 가능하며 문제가 발생했을 때 원인을 찾기도 쉬워진다.

즉 프로그램을 분할한다는 것은 전체적인 효율을 높인다는 것이다.

### 패키지, 크레이트 모듈
러스트의 기본 단위는 모듈이다. 모듈을 모은 것이 크레이트고 크레이트를 관리하는 패키지가 있다.
모듈은 스코프(범위) 단위다. 모듈의 관계는 트리 구조로 표현할 수 있다.
'크레이트(crate)'는 트리 구조로 표현되는 모듈군 전체를 말한다. 모듈의 트리 가장 위에는 크레이트가 있다.
'패키지(package)'는 복수의 크레이트를 관리한다. 패키지 관리 시스템인 Cargo와 밀접하게 엮인 단위로 크레이트를 빌드하거나 테스트 한다.

### 트리 구조인 러스트 모듈
트리 구조는 파일 시스템 등에서 자주 접할 수 잇는 형태로 나무가 가지를 뻗어나가는 형태로 구조가 만들어진다.
XML이나 JSON으로도 트리 구조 데이터를 다룰 수 있다.
러스트의 모듈은 하나의 모듈 아래에 1개 이상의 서브 모듈이 잇으며, 서브 모듈에도 그 하위의 서브 모듈을 가질 수 있다.

### 모듈은 1개의 파일에 여러 개 정의할 수 있다.
파이썬은 1개의 파일은 1개의 모듈로 구성된다. 하지만 러스트는 1개의 파일 안에 여러 개의 모듈을 정의할 수 있다.
선형 합동법과 XorShift라는 2개의 알고리즘을 이용해 32비트 의사난수를 생성하는 모듈을 만들고 그것을 이용하는 프로그램이다.
```rust
// random 모듈 선언
mod random {
	// linear 모듈 선언
	pub mod linear {
		use std::num::Wrapping;
		// 선형 합동법으로 난수 생성
		pub fn rand(seed: &mut u32) -> u32 {
			let (a, c) = (134775813u32, 12345u32);
			*seed = (Wrapping(*seed) * Wrapping(a) +
					Wrapping(c)).0;
			*seed
		}
	}
	
	// xorshift 모듈 선언
	pub mod xorshift {
		//XorShift로 난수 생성
		pub fn rand(seed: &mut u32) -> u32 {
			let mut y = *seed;
			y ^= y << 13;
			y ^= y >> 17;
			y ^= y << 5;
			*seed =y;
		}
	}
}

// 모듈 이용 선언
use random::{linear, xorshift}
fn main() {
	// 각 알고리즘으로 10개의 난수를 생성
	let mut seed1 = 12345u32;
	let mut seed2 = 12345u32;
	for i in 0..10 {
		let r1 = linear::rand(&mut seed1) % 6 + 1;
		let r2 = xorshift::rand(&mut seed2) % 6 + 1;
		println!("L : {:2} 번째 = {}, {}", i+1, r1, r2)
	}
}
```
소스 코드 확인
random 모듈을 정의
모듈은 'mod 모듈 이름 { ... }' 형태로 정의한다. 'mod'는 module을 줄인 것이다.
random 모듈의 서브 모듈인 linear를 정의한 것이다.
이 부분에서는 모듈을 선언할 때 pub을 붙였음
public을 줄인 것으로 해당 모듈을 외부에 공개하겠다는 의미이다.
pub를 붙이지 않으면 그 모듈은 외부에서는 사용이 불가능하다.

의사 난수 생성 알고리즘 '선형 합동법'을 구현한 rand 함수를 정의했다.
러스트 모듈 구조는 A::B::C와 같이 기호'::'로 구분해 표시한다.
이 함수도 만찬가지로 pub을 지정해 외부에서 이용할 수 있게 돼 있다.
random 모듈의 또 다른 서브 모듈인 xorshift를 정의했다. 현재 random 모듈에는 linear 모듈과 xorshift 모듈 2개의 서브 모듈이 정의돼 있다.

random::xorshift 모듈의 rand 함수를 정의한다. 이 함수는 의사 함수를 생성하는 Xorshift 알고리즘을 구현한 것이다. 이 함수도 마찬가지로 pub 선언이 있으므로 외부에서 사용할 수 있다.
main 함수 스코프에서 random 모듈 이하 2개의 서브 모듈을 이용한다는 선언이다.
linear::rand와 xorshift::Rand 함수를 이용해 10개씩의 난수를 생성한다.
> 연산 오버플로(overflow)를 무시하는 방법
> 위 소스 코드에서 (선형 합동법으로 난수 생성)부분의 선형 합동법을 이용한 의사 난수 생성 처리를 보면 Wrapping 메서드가 사용된다. Wrapping 메서드는 연산 오버플로를 무시하는 기능을 제공한다.
> 
> 원래 러스트에서는 연산 오버플로(연산 후 결과 값이 표현 가능한 범위를 넘었을 때)가 발생하면 에러로 처리된다. 하지만 선형 합동법 알고리즘은 오버플로가 발생한 뒤 자릿수를 넘어간 부분을 잘라낸 뒤 난수의 초깃값으로 사용한다. 그래서 Wrapping 메서드를 이용해 오버플로를 무시한다.

### 모듈 정의와 사용
1개의 파일에 들어 있다 하더라도 블록이 다르면 다른 모듈이다. 모듈을 이용하려면 use random::linear 와 같이 따로 선언해야 한다.
이미 설명한 것처럼 러스트의 모듈은 트리 구조로 표현할 수ㅜ 있다. 기능을 정리하기 위해 모듈을 세분화해 관리할 수 있다. 그리고 mod_random.rs에서 본 것 처럼 모듈 안에 있는 요소는 공개, 비공개를 선택할 수 있다. pub을 붙여야 해당 요소를 외부에서 사용할 수 있음

mon_random.rs의 모듈을 트리구조로 그려보면 다음과 같다.
> \<random> 모듈
> |-- \<linear> 모듈
> 	|-- rand 메서드
> |-- \<xorshift> 모듈
> 	|-- rand 메서드

rand 메서드에 접근하려면 random::linear::rand와 같이 모듈 경로를 지정해야 한다. 그리고 rand 메서드를 접근하려면 random::xorshift::rand와 같이 모듈 경로를 지정해야 한다. 같은 이름을 가진 함수지만 구현된 위치가 다르므로 정확한 경로를 지정해야 원하는 메서드에 접근할 수 있다.

### 모듈의 경로
파일 시스템에서도 그렇지만 러스틍의 모듈도 상대 경로를 이용해 다른 모듈을 이용할 수 있다. 한 단계 위의 모듈에 접근하기 위해서는 super 키워들 사용한다.

다음 프로그램은 앞의 mod_random.rs에서 의사 난수 생성 처리를 삭제한 것이다. 그리고 random::xorshift::rand 함수에서 random::linear::rand 함수를 호출한다.
```rust
mod random {
	pub mod linear {
		pub fn rand() -> u32 {
			1
		}
	}
	pub mod xorshift {
		// (*a)의 함수를 호출
		super::linear::rand()
	}
}

fn main() {
	// (*b)의 함수를 호출
	println!("{}", random::xorshift::rand());
}
```

다음과 같은 모듈 전체 경로를 지정해도 된다.
> crate::random::linear::rand()

## 모듈을 파일로 분리하는 방법
모듈을 한 파일에 모을 수도 있지만 각 모듈을 별도의 파일로 구성할 수도 있다.
Cargo로 새로운 프로젝드를 만들고 그 안에 모듈 파일을 만들어 시험해보기

## 정리
\[Rust/rust-in/ch4/rand]
파일별로 모듈을 분리하는 경우 디렉터리 구조와 모듈 경로가 일치한다.
하지만 러스트 컴파일러는 디렉터리 안의 모든 내용을 검색하지는 않는다.

메인 프로그램에서 mod random 이라고 작성하고 random 디렉터리 안에 mod.rs 파일을 만들어야 비로소 random 디렉터리를 모듈로 인식한다. 그리고 mod.rs 파일에서 동일 디렉터리에 존재하는 다른 파일을 모듈로 기입해야 한다. 이때 확장자 .rs는 기입하지 않는다.

> Cargo.toml 파일에 있는 'edition'
> 2장의 칼럼에서 소개한 것처럼 Rust 는 2018보다 오래된 버전에서는 외부 크레이트를 이용하기 위해 'extern crate \_' 라고 기술해야 했지만 2018부터는 직접 크레이트 심볼을 임포트 할 수 있게 됬다.
> extern crate를 생략하려면 Cargo.toml의 \[package]에 edition = "2018" 또는 그 이후로 지정해야한다.
> 참고로 러스트는 대대적인 버전업이 있을 때 해당 연도를 붙인다. edition 2015, 2018, 2021 등이 바로 그것이다. 이 edition 버전에 따라 기존에 동작하던 함수가 동작하지 않는 등 문제가 발생할 수 있다. Cargo.toml에서 지정하는 edition은 호환성을 위한 것이다.

## 상대 경로로 모듈 지정
모듈의 구조는 파일 시스템 구조와 동일한 트리 구조라고 설명했다. 그리고 상대 경로를 이용 가능하다는 설명도 했음. 예를 들어 다음과 같이 2계층 이상의 모듈을 정의했다면 어떻게 모듈을 불러와야 하는지 확인해보자

```rust
mod aaa {
	pub mod bbb {
		pub mod ccc {
			// 함수 정의
			pub fn print() {
				println!("aaa::bbb::ccc::print");
			}
		}
	}
	pub mod ddd {
		pub mod eee {
			// 함수 정의
			pub fn print() {
				println!("aaa::ddd:eee:print");
			}
		}
		pub mod fff {
			// 함수 정의
			pub fn print() {
				// 상대 경로로 함수 호출
				super::eee::print();
				super::super::bbb::ccc::print();
			}
		}
	}
}

fn main() {
	// 경로를 지정해 함수 호출
	aaa::bbb::ccc::print(); //1
	aaa::ddd::eee::print(); //2
	// 최상위 경로부터 지정해 함수 호출
	crate::aaa::ddd::fff::print(); //3
}

```
프로그램에서 모두 print 라는 함수를 정의 했음
메인 함수를 기준으로 상대 경로를 이용해 1, 2를 호출한다.
3번은 절대 경로를 지정해 호출한다.
함수는 상대 경로로 1, 2의 print 함수를 호출
한 단계 위의 모듈을 저정할 때는 super를 사용하고 절대 경로는 crate를 사용한다.

| 설명           | 예                           |
| ------------ | --------------------------- |
| 상대 경로 지정     | aaa::bbb::ccc::print        |
| 1단계 위의 경로 지정 | super::eee::print           |
| 최상위부터 지정     | crate::aaa::bbb::ccc::print |
use 키워드를 이용하면 해당 스코프에서 더 이상 경로를 지정하지 않고 모듈을 이용할 수 있다.

| 설명                  | 예                                    |
| ------------------- | ------------------------------------ |
| 최상위부터 지정해 사용 선언     | use crate::aaa::bbb::ccc::print;     |
| 상대 경로를 지정해 사용 선언    | use aaa::bbb::ccc;                   |
| 1단계 위의 경로 지정        | use super::eee;                      |
| 별칭 지정해 사용 선언        | use aaa::bbb::ccc::print as c_print; |
| 한 계층에서 복수의 모듈 사용 선언 | use aaa::{bbb, ccc};                 |
| 한 계츨 전체 사용 선언       | use aaa::*;                          |

## 패키지
패키지란 복수의 크레이트를 한데 모은 것이다.
2장에서 Cargo를 이용해 새로운 패키지를 만드는 방법을 소개햇다.
러스트의 패키지를 조작하려면 Cargo.toml 파일을 편집한 뒤 Cargo로 빌드 등의 명령을 실행한다.

복수의 크레이트를 편집하려면 '워크스페이스'라는 기능을 사용한다.
워크스페이스를 이용하는 경우도 Cargo.toml 파일을 편집해 Cargo 명령어를 실행한다.
> 워크 스페이스란
> 프로젝트가 커지면 다양한 모듈을 계층에 따라 분리해서 더 효율적인 프로그램을 만드는 노력을 한다.
> 옮긴이의 개인 프로젝트 중 웹 백엔드 부분은 DDD(Domain-Driven Design: 도메인 주도 설계)를 표방해 총 4개의 레이어로 구성했다.
> - api - HTTP 서버, 사용자로부터의 입력값 처리 (입력)
> - application - api에서 전달된 매개변수를 처리해 domain으로 전달, 트랜잭션 처리 (처리)
> - domain - DB에 대한 각종 트레잇과 DB 구조체 정의 (구성 및 정의)
> - infrastructure - domain에서 정의한 트레잇을 구현(impl) (실제 조작)
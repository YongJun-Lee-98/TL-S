제네릭은 다른 타입이라도 동일하게 조작할 수 있게 해주는 기능이다.
이미 Vec과 HashMap을 통해 기본적인 사용방법은 알고 있음
제네릭을 이용한 구조체와 ㅂ녀수의 정의 방법을 소개하기
## 제네릭 복습하기
generic은 추상적인 타입을 지정해 다양한 데이터 타입 조작을 가능하게 하는 프로그래밍 기법이다. 이미 Vec와 HsahMap을 이용해 프로그램을 만들어 봤으므로 제네릭에 대해 어느정도 이해는 하고 있을 것임
Vec으 ㄹ이용한 간단한 프로그램을 만들어 보기
i32 타입과 char 타입 벡터를 만들고 그 조작 방법을 비교하는 것

```rust
fn main() {
	// i32 타입을 Vec을 사용
	let mut v1: Vec<i32> = Vec::<i32>::new();
	v1.push(10);
	v1.push(20);
	v1.push(30);
	v1.pop(); // 마지막 요소 꺼내기
	// v1 변수의 요소를 하나씩 출력
	for i in v1.iter() {
		println!("{}", i);
	}
	
	// char 타입 Vec을 사용
	let mut v2: Vec<char> = Vec::<char>::new();
	v2.push('a'); // 요소를 v2에 추가
	v2.push('b');
	v2.push('c');
	v2.pop(); // 마지막 요소 꺼내기
	// v2 변수의 요소르 하나씩 출력
	for i in v2.iter() {
		println!("{}", i);
	}
}
```

## 제네릭 함수 정의
제네릭을 이용하면 함수나 메서드의 사용 방법을 통일할 수 있다는 장점 외에도 코드 중복을 줄일 수 있다는 장점도 있다.
i32 타입 값을 더하기만 하는 add_i32 함수와 f32 타입 값을 더하기만 하는 add_f32 함수를 만들어야 한다면 다음과 같이 만들 수 있다.

```rust
fn add_i32(a: i32, b: i32) -> i32 {
	a + b
}

fn add_f32(a: f32, b: f32) -> f32 {
	a + b
}

fn main() {
	println!("{}", add_i32(10, 25));
	println!("{}", add_f32(10.0, 25.0))
}
```

add_i32 함수와 add_f32 함수를 보면 타입 선언이 다를 뿐이지 구조는 같다.
러스트는 타입 체크를 엄격하게 하므로 타입이 다르면 컴파일이 되지 않는다. 하지만 타입이 다르기 때문에 다른 함수를 추가로 만들어야 한다는 건 꽤 불편한 일이다. 
이렇게 비슷한 함수가 여러 개 있다면 실수가 발생할 가능성도 높음

이럴 때 이용하는 것이 제네릭이다.
#### 제네릭 예시

```rust
// 제네릭을 이용해 add 정의
fn add <T: std::ops::Add<Output=T>> (a:T, b:T) -> T {
	a + b
}

// 함수 사용하기
fn main() {
	println!("{}", add(10, 25));
	println!("{}", add(10.0, 25.0));
	println!("{}", add::<i32>(10, 25));
}
```

#### 제네릭 함수 정의
> fn 함수명 \<T: 트레잇>(인수1: T, 인수2: T, ...) -> 반환값 {
> ...
> }

제네릭 함수에서는 함수명 뒤에 따라오는 <T: 트레잇> 부분이 중요하다. 제네릭을 사용할 때 이 T 타입부분이 임의의 타입으로 변경된다.
서식을 확인하면서 다시 한번 제네릭인 add 함수를 살펴보자. 서식과 실제 코드를 비교하며 어떻게 구현됐는지 확인하기
> fn add <T: std::ops::Add<Output=T>> (a: T, b: T) -> T {
> 	a + b
> }

러스트는 특성상 컴파일러에서 거의 모든 문제를 처리한다.
제네릭도 예외는 아니며 여기서는 인수와 반환 값 타입 T가임의의 타입으로 변경 될 때 프로그램이 올바르게 컴파일 되는지 확인해야 한다.

T 타입인 'std::ops::Add<Ouput=T>' 는 덧셈과 관련된 트레잇이다. std::ops는 오버로드(overload) 가능한 연산자 트레잇을 정의한 모듈이고, Add 트레잇이 덧셈 트레잇이다.

즉 제네릭에 지정 가능한 타입으로 std::ops::Add 트레잇을 지정하면 그 제네릭은 '덧셈을 할 수 있는 타입'을 지정할 수 있다는 의미이다.
정수 타입 i32와 부동 소수점 타입 f32는 당연히 덧셈가능한 타입이고
char은 덧셈이 불가능하므로 에러가 발생한다.

## 트레잇 제한하기
제네릭 타입에 대해 트레잇을 지정하는 것을 '트레잇 바운드(trait bound- 트레잇 경계)'라고 한다. 어떤 타입에도 지정할 수 있어야 하는 제네릭 타입에 트레잇을 지정한다는 것은 '지정한 트레잇을 구현해야 한다'는 제약을 것이다.

## 인수 값을 2배로 하는 제네릭 함수 정의
제네릭 함수를 만드는 연습을 위해 인수로 지정한 값을 2배로 만드는 함수를 만들어 보자
```rust
// 인수 값을 2배로 만드는 제네릭
fn x2 <T: std::ops::Add<Output=T> + Copy> (n: T) -> T {
	n + n
}
fn main() {
	println!("{}", x2(3));
	println!("{}", x2(3.0f64));
	println!("{}", x2::<u64>(3));
}
```

2배로 만들기 위해 인수로 받은 값을 한 번 더 더하는 것이므로 앞의 예제와 같이 std::ops::Add 트레잇을 지정한다. 이와 동시에 한 변수를 2번 이용하므로 Copy 트레잇을 구현해야 한다.
2개 이상의 트레잇을 지정하는 경우 '+'를 사용한다.

### 제네릭 함수에서 where 사용
제네릭 함수를 만들 때 다음과 같이 where를 이용하는 것도 가능하다.
긴 트레잇을 써야 한다면 where를 이용해 가독성을 높일 수 있다.

> \[서식] 제네릭 함수 정의(where를 사용하는 경우)
> fn 함수명 \<T>(인수1: T, 인수2: T, ...) -> 반환값
> 	where T: 트레잇
> {
> ...
> }

다음은 where를 이용한느 방식으로 add_generics.rs를 수정하는 것
```rust
fn add <T> (a:T, b:T) -> T
	where T: std::ops::Add<Output=T>
{
	a + b
}

fn main() {
	println!("{}", add(10, 25));
	println!("{}", add(10.0, 25.0));
}
```

## 구조체에 제네릭 지정
함수뿐 아니라 구조체를 선언할 때도 제네릭을 지정할 수 있다.
다음 프로그램은 좌표 x와 y 필드를 가진 Point 구조체에 제네릭을 지정하는 예이다.
```rust
#[derive(Debug)]
struct Point<T> {
	x: T,
	y: T,
}

fn main() {
	let pt_i = Point { x: 20, y: 50 };
	let pt_f = Point { x: 20.5, y: 15.3};
	println!("{:?}", pt_i);
	println!("{:?}", pt_f);
}
```
컴파일 후 실행해 본다면 Point 구조체를 초기화 하기 위해 지정한 값에 따라 자동적으로 타입이 결정돼 출력됨을 확인할 수 있다.

> [서식] 구조체에 제네릭 지정
> struct 구조체명 <T, U> {
> 	필드 1: T,
> 	필드 2: U,
> }

### 구조체의 메서드 정의에 제네릭 지정
구조체의 메서드를 정의할 때도 제네릭을 활용할 수 있다. 
```rust
// 구조체 Point 정의
#[derive(Debug)]
struct Point<T> {
	x: T,
	y: T,
}

// 메서드 정의
impl<T> Point<T> where T: std::ops::AddAssign {
	// 생성자
	fn new(x: T, y: T) -> Self {
		Self { x, y }
	}
	// 값 더하기
	fn add(&mut self, pt: Point<T>) {
		self.x += pt.x;
		self.y += pt.y:
	}
}

fn main() {
	// Point 객체 생성
	let mut pt = Point::new(10, 10);
	println!("{:?}", pt);
	// 좌표 값 더하기
	pt.add(Point{ x:20, y:30 });
	println!("{:?}", pt);
}
```
소스코드 설명
구조체 Point<T>를 정의
Debug 속성을 지정해 값을 출력할 수 있음

Point<T> 구조체의 메서드를 정의한다. where에 T 트레잇 바운드를 지정한다.
std::ops::AddAssign 트레잇은 덧셈 대입을 구현하도록 강제한다.

생성자 new 함수 정의

값을 더하기 위해 add 메서드를 정의한다. 구조체의 필드 값 변경을 하기 위해 &mut self 를 지정해 가변 변수라는 것을 명시한다. 
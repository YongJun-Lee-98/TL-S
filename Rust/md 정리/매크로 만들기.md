러트의 매크로 기능은 강력함
여기서는 간단하게 매크로를 만드는 방법을 설명한다.
매크로를 사용하면 보다 쉽게 러스트 프로그래밍을 할 수 있다.

## 러스트의 매크로
여기까지 진행하면서 다양한 러스트의 매크로를 사용했다.
println!, vec!, panic! 같은 매크로 없이 어떻게 프로그래밍을 해야할지 모를 정도이다.
그중 println!은 가장 처음 소개한 프로그램에서도 나왔고
러스트와 떼려야 뗄 수 없는 것이 바로 매크로이다.

### 러스트에서 매크로를 사용해야 하는 경우
어떤 경우 러스트에서 매크로를 사용할까.
매크로란 원래 프로그램 실행 전에 어떤 규칙에 따라 프로그램을 다시 작성하는 기능을 수행한다.
즉 러스트에서 매크로란 프로그램을 만드는 프로그램 이라고 할 수 있다.
매크로와 함수는 비슷하게 보이지만 함수는 프로그램이 실행될 때 동작하는 반면 매크로는 프로그램이 컴파일될 때 실행돼 프로그램 자체를 변경한다.

### 2 종류의 매크로
러스트에는 크게 나눠 2종류의 매크로가 준비돼 있다.
함수처럼 사용할 수 있는 '선언적 매크로(declarative macro)' 와 구조체에 속성을 부여할 때 추가될 코드를 지정하는 '절차적 매크로(procedural macro)'다.

선언적 매크로 vec! 매크로처럼 중복된 기술을 해야 하는 경우 간편하게 작성할 수 있도록 하기 위한 것
선언적 매크로를 사용함으로써 좀 더 간단하게 프로그래밍이 가능하다.
println!이나 vec!에서는 가변 길이의 인수를 받는다.
매크로를 이용하면 문법을 확장하거나 소유권을 좀 더 쉽게 다룰 수 있다는 장점이 있다.

절차적 매크로는 구조체에 자동으로 메서드 등을 추가하기 위한 역할을 한다.
예를 들어 구조체를 선언할 때 \#\[derive(Clone, Copy)] 라는 선언을 추가하면 구조체를 복사하거나 복사본을 만드는 메서드가 추가된다.
구조체 뿐 아니라 함수에도 속성을 추가할 수 있다.
절차적 매크로를 만드는 경우 러스트의 구문 요소를 TokenStream으로 받아 러스트 코드를 만들 수 있게 프로그램을 작성한다.

## 매크로 정의하기
간단한 매크로를 하나 만들어보기
선언적 매크로를 만들기 위해서는 macro_rule!을 이용한다.

> \[서식] 선언적 매크로 정의
> macro_rules! 매크로 이름 {
> 	(패턴 1) => { 생성할 프로그램 1 };
> 	(패턴 2) => { 생성할 프로그램 2 };
> }

숫자 값을 화면에 표현하는 단순한 매크로 'echo_num!'을 작성해보기
```rust
// 숫자 값을 출력하는 매크로
macro_rules! echo_num {
	($num:expr) => { println!("{}", $num); }
}

// 매크로 이용
fn main() {
	echo_num!(10);
	echo_num![20];
	echo_num!{30};
}
```
echo_num 이라는 매크로를 정의했다.
매크로 패턴 ($num:expr)이 지정되면
println!("{}", $num)이 출력되는 단순한 구조이다.
expr은 러스트의 표현식을 의미한다.
여기서는 러스트 표현식을 $num이라는 변수에 대입한다. 그리고 이 정의에서 보면 알 수 있듯 매크로 안에서 다른 매크로를 이용할 수 있다.

main은 매크로를 이용하는 부분이다.
매크로는 예제에서와 같이 어떤 괄호를 이용해도 문제가 없다. 중괄호의 경우에는 마지막 ;을 생략할 수 있다.

## 가변 인수 매크로 정의하기
앞에서 정의한 echo_num! 매크로는 한 번에 하나의 인수밖에 넣을 수 없다.
이를 좀 개량해 가변 인수를 지정할 수 있게 수정해보자
```rust
// 2개 이상의 인수를 표시할 수 있는 매크로 정의 - 1
#[macro_export]
macro_rules! echo_nums {
	( $( $num:expr),* ) => {
		$(
			print!("{}, ", $num);
		)*
		println!("");
	}
}

// 매크로 이용
fn main() {
	echo_nums![10, 20, 30, 40, 50];
	echo_nums!(60, 70);
	echo_nums!{80, 90, 100}
}
```

매크로 선언 앞의 \#\[macro_export]는 다른 파일에서 이 파일을 읽어들였을 때 이 매크로를 사용할 수 있게 한다는 선언이다.
이번에는 가변 인수를 표현하므로 조금 표현이 복잡함
패턴 ( $( $num:expr),\*) 는 반복된 처리를 위한 내용이다.
$( ... ), \* 는 쉼표(,)로 구분된 반복을 나타낸다. 만약 $( ... ); \* 로 기술하면 세미콜론으로 구분된 반복을 나타내는 것이다. 생성할 프로그램도 반복 처리가 필요하므로 $( ... ) \* 형식으로 작성한다.
이렇게 ... 부분을 반복하는 프로그램이 생성된다.

### 매크로 정의에 지정할 수 있는 요소
매크로를 정의할 때 러스트에서 사용하는 대부분의 구문을 인색해 읽을 수 있다.
패턴에 expr을 지정해 표현식과 값이 매치되도록 했지만 매크로에는 이 외에도 다양한 패턴 요소를 이용할 수 있다.

| 지시자   | 의미                                  |
| ----- | ----------------------------------- |
| expr  | 표현식, 값                              |
| item  | 함수, 구조체, 상수, 모듈과 같은 아이템             |
| block | 블록 { ... }으로 감싼 부분                  |
| stmt  | 문장(쉼표가 없는 문장)                       |
| pat   | 패턴                                  |
| ty    | 타입                                  |
| ident | 식별자(변수 이름 등)                        |
| path  | xxx::yyy::zzz와 같이 정의된 경로            |
| tt    | 트리 구조(싱글 토큰)                        |
| meta  | 속성 내용 #\[ ... ] 또는 #!\[ ... ] 안의 내용 |

### 매크로를 이용해 BASIC의 for문 만들기
블록을 이용해 BASIC 언어의 for 문을 만들어보자 BASIC 언어에서는 for i = \[시작 값] to \[ 종료 값] step \[ 증가할 값] 형태로 for 문을 이용한다. 즉 1에서 10까지 값을 2씩 증가시킨다는 구문이라면 'for i = 1 to 10 step 2'라는 형태다.

```rust
// BASIC 문법 for 문 매크로 정의
macro_rules! basic_for{
	// for i = 1 to 10과 같이 작성하는 경우
	(
		for $i:ident = $from::tt to $to:tt
		$block:block
	) => {{
		for $i in $from..=$to {
			$block 
		}
	}};
	// for i = 1 to 10 step 2와 같이 작성하는 경우
	(
		for $i:ident = $from:tt to $to:tt step $step:tt
		$block:block
	) => {{
		let mut $i = $from;
		loop {
			if $i > $to { break }
			$block
			$i += $step
		}
	}};
}

fn main() {
	// 매크로를 이용해 1부터 10까지의 합계 구하기
	let mut total = 0;
	basic_for! {
		for i = 1 to 10 {
			total += i;
		}
	}
	println!("{}", total);
	// 매크로를 이용해 0부터 10까지 3이 증가할 때마다 출력하기
	basic_for! {
		for i = 0 to 10 step 3 {
			println!("i={}", i);
		}
	}
}
```
basic_for! 매크로는 두가지 패턴에 대응하도록 구성되어 있음
1번 'for i = 1 to 10' 의 형태
2번 'for i = 1 to 10 step 2' 의 형태
단순 증가 구문으로도 사용 가능하고 증가 값(step)을 지정한 형태로도 사용이 가능하다
러스트의 매크로를 이용하면 어느정도 자신만의 문법을 만들 수 있다.

매크로 정의 부분인 1과 2를 보면 반복을 시작하는 값과 종료하는 값을 지정할 때 표현식인 expr이 아니라 트리구조를 나타내는 tt를 사용하고 있다. expr을 사용하는 경우 값 뒤에 쉼표 또는 세미콜론을 붙여야 하기 때문에 의도한 동작을 할 수 없기 때문이다.
러스트의 매크로는 이와 같이 러스트 문법을 벗어난 자기만의 문법도 표현할 수 있는 매우 강력한 기능을 가지고 있다.

## HashMap을 간편하게 초기화 하는 매크로 만들기
조금 실용적인 매크로를 만들오보는 예제임
러스트에는 벡터를 초기화하는 vec! 매크로는 있지만 HashMap을 편하게 초기화 할 수 있는 매크로는 존재하지 않는다. 따라서 HashMap을 간편하게 초기화하는 매크로를 만들어본다.

```rust
// HashMap 초기화 매크로 - 1
macro_rules! map_init {
	( $($key:expr => $val:expr),*) => {{
		// HashMap 객체 생성 - 2
		let mut tmp = std::collections::HashMap::new();
		$(
			// 반복해서 값 넣기 -3
			tmp.insert($key, $val);
		)*
		tmp // 객체 반환 - 4
	}}
}

fn main() {
	// 매크로로 HashMap 초기화 - 5
	let week = map_init![
		"mon" => "월요일",
		"tue" => "화요일",
		"wed" => "수요일",
		"thu" => "목요일",
		"fri" => "금요일",
		"sat" => "토요일",
		"sun" => "일요일"
	];
	println!("mon={}", week["mon"]);
	println!("wed={}", week["wed"]);
}
```

1에서 HashMap 초기화 매크로인 map_init을 정의하고 패턴을 지정한다.
HashMap의 요소는 동적으로 정의되므로 패턴에는 반복을 의미하는 '${ ... }, \*'을 지정한다.
HsahMap 객체를 생성한 뒤 반복 구문에서 HashMap에 키와 값을 추가하도록 구성한다.
모든 요소가 HashMap 객체에 추가되면 반복문은 종료되고 4부분에서 객체 반환된다.

5에서는 이렇게 만든 매크로를 이용해 week 변수에 HashMap 값을 할당한다.
자주 사용하는 기능을 이렇게 매크로로 만들어두면 효율적인 프로그래밍이 가능하다.

매크로의 반복 패턴
- \* : 0회 이상의 반복
- + : 1회 이상의 반복
- ? : 0회나 1회

## 매크로 재귀 호출
매크로를 이용한 재귀 호출도 가능하다. 재귀 호출을 구현하려면 약간의 요령이 있어야함
다음은 매크로의 재귀 호출을 이용해 HTML 구조를 출력하는 예이다.

```rust
// 재귀적으로 HTML 구조를 출력하는 매크로
macro_rules! out_html {
	// 인수가 없을 때 - 1
	() => {()};
	// 인수가 1개일 때 - 2
	($e:tt) => {print!("{}", $e)};
	// 태그 [ 안쪽 ]을 계속 지정하는 경우 - 3
	($tag:ident [ $($inner:tt)* ] $($rest:tt)*) => {{
		print!("<{}>", stringify!($tag));
		out_html!($($inner)*);
		println!("</{}>", stringify!($tag));
		out_html!($($rest)*);
	}};
}
fn main() {
	// 매크로를 이용해 HTML 구조를 출력 - 4
	out_html!(
		html [
			head[title["test"]]
			body[
				h1["test"]
				p ["This is test."]
			]
		]
	);
}
```

이 매크로는 재귀 처리를 염두에 두고 있으므로 최소 단위로 호출되는 경우도 고려해서 구현해야 한다.
인수가 없을 때와 1개의 인수만 있을 때, 그리고 2개 이상의 인수가 있을 때를 모두 고려해야 하는 것이다.
1과 같이 인수가 없다면 아무것도 하지 않게 지정한다.
이 부분을 지정하지 않으면 매크로를 호출할 때 에러가 발생한다.
2에서는 인수가 1개일 경우의 규칙을 지정한다.
즉 '태그\[텍스트]'를 지정한 경우에 동작할 부분이다.
3은 태그\[태그\[...]] 와 같은 형태가 지정됐을때의 규칙이다.
이 부분에서는 러스트의 구문 요소를 바탕으로 반복 요소를 얻고 있다.
여기서는 반복 연산자로 \*를 사용해 0회 이상의 반복을 실시해 매크로를 재귀호출한다.
이때 반복이 0회라면 인수가 없는 것이므로 1이 호출된다.
메인 함수에서 매크로를 호출하는 구문은 연속적으로 태그가 사용되었으므로 3의 동작이 적용된다.

## 실제 매크로가 만들어낸 코드 보기 - 매크로 전개
매크로는 컴파일이 될 때 동작하므로 매크로가 생성한 코드를 실제로 볼 수 없다.
하지만 Cargo를 이용해 cargo-expand를 설치하면 매크로가 실제로 어떤 코드를 만들어내는지 알 수 있음
cargo install cargo-expand
## 문항
[11726](https://www.acmicpc.net/problem/11726)

풀이 준비
---
### 1. 문제 요약 (1~2 줄로)
> ex) 트리에서 두 노드 사이의 최장 거리 구하기

2xn 크기의 직사각형을 1x2, 2x1 타일로 채우는 방법의 수를 구하여라

---
### 2. 단순하게 먼저 해보기
> 제한이 작으면 직접 돌리기
> - 시간복잡도는?
> - 어떤 케이스에서 느릴까?

단순하게 2xn 이니까 n을 입력받고
n을 1과 2로 만드는 가짓수
방법의 수니까 개수는 무의미하다.
만들 수 있는 개수를 어떻게 bottom up 방법을 셀 것인가?

dp\[1] = 1
dp\[2] = 2, 1+1
dp\[3] = 1+1+1, 1+2, 2+1
dp\[4] = 1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2

그리고 출력은 10,007로 나눈 '나머지'를 출력한다.

---
### 3. 핵심 아이디어 뽑기
> "이건 \[알고리즘 명]으로 해결해야한다."

다익스트라 알고리즘 해결

---
### 4. Edge Case 스스로 질문하기
> - 루트가 없을 수도 있는지
> - 사이클이 없다고 했나
> - 배열 길이 0인 경우


---
### 5. 해결 전략 결정
> - 완전탐색 / DFS / DP

<details>
<summary>문제가 안풀릴 때</summary>

1. 놓친 조건은 없는가?
2. 단순하게 풀기라도 풀 수는 있는가?
3. 비슷한 문제를 본 적 있나?
4. 핵심 아이디어 한 줄로 요약하면 뭘까?
5. 내가 이 문제를 만든다면 어떤 구조일까?

</details>

<details>
<summary>풀기 연습 방법</summary>

Tree Diameter 문제 인 경우
-> 가중치가 있다면?
-> 노드가 아니라 엣지가 기준이면?
-> 루트가 없으면 어떻게 해야 하지?

한 문제를 깊게 파는 것

</details>

풀이 시작
---

### 구현하기
> 테스트 자동화

```python
def user_def(n):
	dp = [0] * (n + 1)
	dp[1] = 1
	dp[2] = 2
	
	for i in range(3, n + 1):
		dp[i] = dp[i - 1] + dp[i - 2]
	return dp[i] % 10007

if __name__ == "__main__":
	n = int(input())
	print(user_def(n))
```

### 개선 풀이
구현에서 문제 추가 생각
dp를 구하는 것은 옳음
다만, 다음 것을 알기 위해서는 전체를 메모리에 저장할 필요가 없음
따라서 -> 필요한 것만 저장 

어떻게 한 번에 떠올릴까?
dp에서 이전 계산된걸 어떻게 사용되는지 점화식에 규칙이 있으면 될 듯

```python
n = int(input())
a, b = 1, 2
for _ in range(3, n + 1):
	a, b = b, (a + b) % 10007

print(b if n>1 else a)
```
